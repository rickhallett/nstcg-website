Excellent. We are moving methodically through the foundational layers. With the core engine (`StateManager`, `EventBus`, `Component`, `DOM Synchronizer`) and the primary external communication (`ApiService`, `NotionService`, `I18nService`) blueprinted, we can now complete the architectural skeleton.

The next four blueprints will establish the remaining core services and the first concrete `Model` and `Component` implementations that bring the application to life. This will give us a fully functional, albeit minimal, slice of the application, proving the viability of the entire architecture.

The order will be:
1.  **`ErrorHandlerService.js`**: The global safety net.
2.  **`AssetService.js`**: The manager for all non-JS/CSS content.
3.  **`CounterComponent.js`**: Our first simple, reactive UI component.
4.  **`ParticipantModel.js`**: The business logic for participants and counts.

---

### **Blueprint 1 of 4: `ErrorHandlerService.js`**

**Module Objective:** To create a centralized, singleton service for catching all unhandled exceptions, logging them with rich context, and notifying the user in a non-disruptive way.

**Architectural Role:** This is the application's global safety net. It integrates with the `LoggerService` and `EventBus` to ensure that unexpected errors are handled gracefully and consistently.

**File: `tests/core/ErrorHandlerService.test.js`**

```javascript
import { ErrorHandlerService } from '../../js/core/ErrorHandlerService.js';
import { LoggerService } from '../../js/core/LoggerService.js';
import { EventBus } from '../../js/core/EventBus.js';
import { expect } from '../../js/testing/expect.js';
import { describe, it, beforeEach, mockFn, mockSpy } from '../../js/testing/veritas.js';

// Mock dependencies
jest.mock('../../js/core/LoggerService.js');
jest.mock('../../js/core/EventBus.js');

describe('ErrorHandlerService', () => {
  let errorHandlerService;
  let mockLoggerInstance;
  let mockEventBusInstance;

  beforeEach(() => {
    ErrorHandlerService._resetInstance();
    LoggerService._resetInstance();
    EventBus._resetInstance();
    
    errorHandlerService = ErrorHandlerService.getInstance();
    mockLoggerInstance = LoggerService.getInstance();
    mockEventBusInstance = EventBus.getInstance();
  });

  it('should be a singleton', () => {
    // const instance2 = ErrorHandlerService.getInstance();
    // expect(errorHandlerService).toBe(instance2);
  });

  it('should attach global error listeners on init()', () => {
    // const windowSpy = mockSpy(window, 'addEventListener');
    // errorHandlerService.init();
    // expect(windowSpy).toHaveBeenCalledWith('error', expect.any(Function));
    // expect(windowSpy).toHaveBeenCalledWith('unhandledrejection', expect.any(Function));
  });

  describe('handleError()', () => {
    it('should log the error with level "ERROR" using the LoggerService', () => {
      // const error = new Error('A critical failure');
      // errorHandlerService.handleError(error, { source: 'test' });
      // expect(mockLoggerInstance.error).toHaveBeenCalledWith('A critical failure', expect.objectContaining({
      //   source: 'test',
      //   stack: expect.any(String)
      // }));
    });

    it('should emit a "ui:show:error" event on the EventBus with a user-friendly message', () => {
      // const error = new Error('A critical failure');
      // errorHandlerService.handleError(error);
      // expect(mockEventBusInstance.emit).toHaveBeenCalledWith('ui:show:error', {
      //   message: 'An unexpected error occurred. Please try again later.'
      // });
    });

    it('should extract and use a custom user-friendly message if the error is an ApplicationError', () => {
      // // Assuming a custom error class like: class APIError extends Error { constructor(msg, userMsg) { super(msg); this.userMessage = userMsg; } }
      // const apiError = new APIError('Not Found', 'The requested resource could not be found.');
      // errorHandlerService.handleError(apiError);
      // expect(mockEventBusInstance.emit).toHaveBeenCalledWith('ui:show:error', {
      //   message: 'The requested resource could not be found.'
      // });
    });

    it('should not emit a "ui:show:error" event if the error has a "silent" flag', () => {
      // const silentError = new Error('Silent failure');
      // silentError.silent = true;
      // errorHandlerService.handleError(silentError);
      // expect(mockLoggerInstance.error).toHaveBeenCalled(); // Should still be logged
      // expect(mockEventBusInstance.emit).not.toHaveBeenCalledWith('ui:show:error', expect.any(Object));
    });
  });
});
```

---

### **Blueprint 2 of 4: `AssetService.js`**

**Module Objective:** To create a centralized service for loading and caching non-JS/CSS assets like JSON data files and third-party scripts.

**Architectural Role:** This service abstracts away the mechanics of fetching and parsing data files and ensures that assets are only loaded once, improving performance. It's a key part of our Service Layer.

**File: `tests/services/AssetService.test.js`**

```javascript
import { AssetService } from '../../js/services/AssetService.js';
import { expect } from '../../js/testing/expect.js';
import { describe, it, beforeEach, mockFn } from '../../js/testing/veritas.js';

describe('AssetService', () => {
  let assetService;
  let mockFetch;

  beforeEach(() => {
    mockFetch = mockFn();
    global.fetch = mockFetch;
    AssetService._resetInstance();
    assetService = AssetService.getInstance();
  });

  describe('getJSON()', () => {
    it('should fetch a JSON file and return the parsed data', async () => {
      // const jsonData = { key: 'value' };
      // mockFetch.mockResolvedValue({ ok: true, json: () => Promise.resolve(jsonData) });
      // const data = await assetService.getJSON('/data/test.json');
      // expect(mockFetch).toHaveBeenCalledWith('/data/test.json');
      // expect(data).toEqual(jsonData);
    });

    it('should return cached data on the second request for the same JSON file', async () => {
      // const jsonData = { key: 'value' };
      // mockFetch.mockResolvedValue({ ok: true, json: () => Promise.resolve(jsonData) });
      
      // await assetService.getJSON('/data/test.json'); // First call
      // await assetService.getJSON('/data/test.json'); // Second call
      
      // expect(mockFetch).toHaveBeenCalledTimes(1);
    });

    it('should throw an error if fetching the JSON fails', async () => {
      // mockFetch.mockRejectedValue(new Error('Network failure'));
      // const promise = assetService.getJSON('/data/fail.json');
      // await expect(promise).toThrow('Network failure');
    });
  });

  describe('loadScript()', () => {
    it('should create a script tag and append it to the document head', async () => {
      // // We can't easily test the script's onload, so we test the DOM manipulation
      // const scriptUrl = 'https://third-party.com/library.js';
      // // Mock the script's onload event to resolve the promise immediately
      // document.head.appendChild = mockFn().mockImplementation(script => {
      //   script.onload();
      // });
      
      // await assetService.loadScript(scriptUrl);
      
      // expect(document.head.appendChild).toHaveBeenCalled();
      // const scriptTag = document.head.appendChild.mock.calls[0][0];
      // expect(scriptTag.tagName).toBe('SCRIPT');
      // expect(scriptTag.src).toBe(scriptUrl);
      // expect(scriptTag.async).toBe(true);
    });

    it('should not add the same script twice', async () => {
      // document.head.appendChild = mockFn().mockImplementation(script => script.onload());
      // const scriptUrl = 'https://third-party.com/library.js';
      
      // await assetService.loadScript(scriptUrl);
      // await assetService.loadScript(scriptUrl);
      
      // expect(document.head.appendChild).toHaveBeenCalledTimes(1);
    });
  });
});
```

---

### **Blueprint 3 of 4: `CounterComponent.js`**

**Module Objective:** To create our first simple, state-driven UI component. It will display a number and automatically update when the corresponding state changes.

**Architectural Role:** This is our "Hello, World!" for the Component Architecture. It will prove that a "dumb" component can be created and reactively updated by the `StateManager` and `DOM Synchronizer`.

**File: `tests/components/Counter/CounterComponent.test.js`**

```javascript
import { CounterComponent } from '../../js/components/Counter/CounterComponent.js';
import { StateManager } from '../../js/core/StateManager.js';
import { expect } from '../../js/testing/expect.js';
import { describe, it, beforeEach } from '../../js/testing/veritas.js';

describe('CounterComponent', () => {
  let host;
  let stateManager;

  beforeEach(() => {
    document.body.innerHTML = '<div id="host"></div>';
    host = document.getElementById('host');
    StateManager._resetInstance();
    stateManager = StateManager.getInstance();
    stateManager.initialize({ stats: { participantCount: 100 } });
  });

  it('should render the initial count from props on attach()', () => {
    // const counter = new CounterComponent(host, { count: 50 });
    // counter.attach();
    // expect(host.textContent).toBe('50');
  });

  it('should render the initial count from StateManager if no props are provided', () => {
    // // This component will subscribe to 'stats.participantCount'
    // const counter = new CounterComponent(host, {});
    // counter.attach();
    // expect(host.textContent).toBe('100');
  });

  it('should reactively update when the subscribed state changes', () => {
    // const counter = new CounterComponent(host, {});
    // counter.attach(); // Renders "100"
    
    // stateManager.set('stats.participantCount', 250);
    
    // expect(host.textContent).toBe('250');
  });

  it('should use a label from props if provided', () => {
    // const counter = new CounterComponent(host, { count: 10, label: 'Participants' });
    // counter.attach();
    // expect(host.innerHTML).toContain('<span class="label">Participants</span>');
  });

  // This tests the intelligent diffing.
  it('should update only the number text node, not the entire component, on change', () => {
    // const counter = new CounterComponent(host, { count: 10, label: 'Participants' });
    // counter.attach();
    
    // const labelElement = host.querySelector('.label');
    // const numberElement = host.querySelector('.number');
    
    // stateManager.set('stats.participantCount', 250); // Will trigger an update
    
    // expect(host.querySelector('.label')).toBe(labelElement); // The label element should be the same object
    // expect(host.querySelector('.number')).not.toBe(numberElement); // The number node may be new
    // expect(host.querySelector('.number').textContent).toBe('250');
  });
});
```

---

### **Blueprint 4 of 4: `ParticipantModel.js`**

**Module Objective:** To encapsulate the business logic for fetching and managing participant data.

**Architectural Role:** This `Model` will be responsible for orchestrating calls to the `NotionService` and updating the `StateManager` with participant counts and lists.

**File: `tests/models/ParticipantModel.test.js`**

```javascript
import { ParticipantModel } from '../../js/models/ParticipantModel.js';
import { NotionService } from '../../js/services/NotionService.js';
import { StateManager } from '../../js/core/StateManager.js';
import { expect } from '../../js/testing/expect.js';
import { describe, it, beforeEach, mockFn } from '../../js/testing/veritas.js';

jest.mock('../../js/services/NotionService.js');
jest.mock('../../js/core/StateManager.js');

describe('ParticipantModel', () => {
  let participantModel;
  let mockNotionService;
  let mockStateManager;

  beforeEach(() => {
    NotionService.mockClear();
    StateManager._resetInstance();

    participantModel = new ParticipantModel();
    mockNotionService = NotionService.mock.instances[0];
    mockStateManager = StateManager.getInstance();
  });

  describe('fetchParticipantCount()', () => {
    it('should call NotionService.getParticipantCount()', async () => {
      // mockNotionService.getParticipantCount.mockResolvedValue(215);
      // await participantModel.fetchParticipantCount();
      // expect(mockNotionService.getParticipantCount).toHaveBeenCalled();
    });

    it('should update the StateManager with the fetched count', async () => {
      // const fakeCount = 250;
      // mockNotionService.getParticipantCount.mockResolvedValue(fakeCount);
      // await participantModel.fetchParticipantCount();
      // expect(mockStateManager.set).toHaveBeenCalledWith('stats.participantCount', fakeCount);
    });

    it('should return the fetched count', async () => {
      // const fakeCount = 300;
      // mockNotionService.getParticipantCount.mockResolvedValue(fakeCount);
      // const count = await participantModel.fetchParticipantCount();
      // expect(count).toBe(fakeCount);
    });
  });

  describe('fetchRecentSignups()', () => {
    it('should call NotionService.getRecentParticipants with a default limit', async () => {
      // mockNotionService.getRecentParticipants.mockResolvedValue([]);
      // await participantModel.fetchRecentSignups();
      // expect(mockNotionService.getRecentParticipants).toHaveBeenCalledWith({ limit: 10 });
    });

    it('should update the StateManager with the list of recent signups', async () => {
      // const fakeSignups = [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }];
      // mockNotionService.getRecentParticipants.mockResolvedValue(fakeSignups);
      // await participantModel.fetchRecentSignups();
      // expect(mockStateManager.set).toHaveBeenCalledWith('feed.recentSignups', fakeSignups);
    });
  });
});
```